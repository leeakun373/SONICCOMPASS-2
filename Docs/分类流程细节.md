# 分类流程详细说明

## 概述

Sonic Compass 采用 **4级瀑布流分类逻辑**，从最高确定性到最低确定性，逐级降级匹配。一旦在某一级找到有效分类，**立即返回，不会继续执行后续逻辑**。

---

## 分类流程详解

### Level -1: 短路逻辑（Short-Circuit Logic）⭐ 最高优先级

**匹配目标**: `filename`（文件名）

**匹配方式**: 
- 从文件名中直接提取标准的 UCS CatID
- 例如：`AEROHeli_Helicopter_01.wav` → 提取 `AEROHeli`
- 使用 O(1) 集合查找，性能极快

**匹配规则**:
- 将文件名按 `_` 和 `-` 分割成多个部分
- 检查每个部分是否是有效的 UCS CatID（在 `valid_catids_set` 中）
- 如果找到，进行双重验证（`valid_catids_set` + `catid_to_category`）
- **返回原始格式的 CatID**（如 `ANMLAqua`），保持官方 UCS 格式

**特点**:
- ✅ **准确率 100%**：直接匹配标准 CatID，无歧义
- ✅ **性能 O(1)**：集合查找，无需复杂计算
- ✅ **避免错误**：防止后续逻辑引入错误分类
- ✅ **一旦匹配成功，立即返回，不会继续执行后续逻辑**

**示例**:
```
文件名: "RUBRCRSH_Test_01.wav"
→ 提取: "RUBRCRSH"
→ 验证: 在 valid_catids_set 中 ✓
→ 返回: "RUBRCRSH"（不再执行后续逻辑）
```

---

### Level 0: 强规则（Strong Rules）

**匹配目标**: `rich_text`（富文本上下文）

**rich_text 包含的字段**（按优先级）:
- `Filename`（文件名）
- `Description`（描述）
- `Keywords`（关键词）
- `VendorCategory`（供应商类别）
- `Library`（库名）
- `BWDescription`（BW 描述）
- `Notes`（备注）
- `FXName`（效果名称）

这些字段会被拼接成一个完整的文本字符串。

**匹配方式**: 
- 在 `rich_text` 中查找 `ucs_alias.csv` 中定义的关键词
- 使用 **整词匹配**（Whole Word Matching）
- 正则表达式：`\b{keyword}\b`（`\b` 确保单词边界）

**匹配规则**:
- ✅ **完全匹配**：只匹配完整单词，不是部分匹配
- ✅ **不区分大小写**：关键词和文本都转换为小写后匹配
- ✅ **防止误匹配**：例如 "train" 不会匹配 "training"

**示例**:
```
rich_text: "laser gun weapon fire"
关键词: "lasergun"（在 ucs_alias.csv 中）
→ 匹配: "lasergun" 不在 rich_text 中（因为 rich_text 是 "laser gun"，两个词）
→ 不匹配

rich_text: "lasergun weapon fire"
关键词: "lasergun"
→ 匹配: ✓ 找到 "lasergun"
→ 返回: 对应的 CatID（如 "LASRGun"）
```

**注意**: 
- 如果 Level -1 已经匹配成功，**不会执行此步骤**
- 如果此步骤匹配成功，**立即返回，不会继续执行后续逻辑**

---

### Level 1: 显式 Metadata（Explicit Metadata）

**匹配目标**: `raw_cat`（原始 metadata 中的 `category` 字段）

**匹配方式**:
- 直接读取数据库中的 `category` 字段
- 不涉及 AI，只是验证和规范化
- 使用 `enforce_strict_category()` 进行严格验证

**验证规则**:
- 如果 `raw_cat` 是有效的 UCS CatID → 直接使用
- 如果 `raw_cat` 是别名 → 通过 `resolve_alias()` 解析为标准 CatID
- 如果 `raw_cat` 无效 → 返回 "UNCATEGORIZED"

**过滤条件**:
- 跳过 "MISC" 类别（通常不够精确）
- 跳过 "UNCATEGORIZED"（已经是未知类别）

**特点**:
- ❌ **不涉及 AI**：纯查表验证
- ✅ **尊重原始数据**：如果原始数据中已经有有效的 CatID，直接使用
- ✅ **严格验证**：确保返回的 CatID 是合法的 UCS 标准类别

**示例**:
```
原始 metadata: {"category": "AIRBlow"}
→ 验证: "AIRBlow" 是有效的 UCS CatID ✓
→ 返回: "AIRBlow"（不再执行后续逻辑）

原始 metadata: {"category": "Gun"}
→ 验证: "Gun" 不是标准 CatID，尝试解析别名
→ 解析: "Gun" → "WPNGun"（通过 ucs_alias.csv）
→ 返回: "WPNGun"（不再执行后续逻辑）
```

**注意**: 
- 如果 Level -1 或 Level 0 已经匹配成功，**不会执行此步骤**
- 如果此步骤匹配成功，**立即返回，不会继续执行后续逻辑**

---

### Level 2: AI 向量匹配（AI Vector Matching）🤖

**匹配目标**: `rich_text`（富文本上下文，与 Level 0 相同）

**匹配方式**:
- 使用 `VectorEngine` 将 `rich_text` 编码为向量
- 与预计算的 **Platinum Centroids**（754 个 UCS CatID 的向量质心）比较
- 使用余弦相似度（`np.dot(vector, centroid)`）计算相似度
- 选择相似度最高的 CatID

**匹配规则**:
- ✅ **相似度阈值**: `> 0.4`（如果最高相似度 < 0.4，返回 "UNCATEGORIZED"）
- ✅ **使用所有 metadata 信息**：`rich_text` 包含所有相关字段
- ✅ **语义理解**：AI 可以理解语义相似性（例如 "gun" 和 "weapon"）

**特点**:
- ✅ **智能匹配**：可以处理复杂的语义关系
- ⚠️ **计算成本高**：需要向量化和相似度计算
- ⚠️ **可能出错**：AI 可能产生错误的分类

**示例**:
```
rich_text: "magical fireball spell explosion"
→ 向量化: [0.123, 0.456, ...]
→ 与 Platinum Centroids 比较
→ 最高相似度: 0.65（匹配到 "MAGCFIRE"）
→ 返回: "MAGCFIRE"（如果相似度 > 0.4）
```

**注意**: 
- 如果 Level -1、Level 0 或 Level 1 已经匹配成功，**不会执行此步骤**
- 这是**唯一使用 AI 的步骤**
- 如果所有前面的步骤都失败，才会执行此步骤

---

## 关键问题解答

### Q1: 如果短路逻辑（Level -1）已经验证完了，还会漏到后面改变分类吗？

**答案：不会。**

一旦在 Level -1 找到有效的 CatID，代码会执行：
```python
return validated, ""  # 找到了就直接返回，跳过后续所有逻辑
```

这意味着：
- ✅ 不会执行 Level 0（强规则）
- ✅ 不会执行 Level 1（显式 Metadata）
- ✅ 不会执行 Level 2（AI 预测）

**分类结果已经确定，不会改变。**

---

### Q2: 匹配失败后，是去找 filename 还是其他字段的富文本拼凑成的内容再去 ucs alias 里匹配？

**答案：使用 `rich_text`（富文本上下文）。**

**Level 0（强规则）的匹配流程**：
1. 从 `meta_dict` 中获取 `rich_text`（如果不存在，使用 `semantic_text`）
2. `rich_text` 包含多个字段的拼接：
   - `Filename`（文件名）
   - `Description`（描述）
   - `Keywords`（关键词）
   - `VendorCategory`（供应商类别）
   - `Library`（库名）
   - `BWDescription`（BW 描述）
   - `Notes`（备注）
   - `FXName`（效果名称）
3. 在 `rich_text` 中查找 `ucs_alias.csv` 中定义的关键词
4. 使用 **整词匹配**（`\b{keyword}\b`），确保只匹配完整单词

**匹配类型**：
- ✅ **完全匹配**（Whole Word Matching）：只匹配完整单词
- ❌ **不是部分匹配**：例如 "train" 不会匹配 "training"
- ❌ **不是模糊匹配**：必须精确匹配关键词

**示例**：
```
rich_text: "laser gun weapon fire"（来自 Filename + Description + Keywords）
关键词: "lasergun"（在 ucs_alias.csv 中）
→ 不匹配（因为 "lasergun" 不在 rich_text 中，rich_text 是 "laser gun" 两个词）

rich_text: "lasergun weapon fire"
关键词: "lasergun"
→ 匹配 ✓（找到完整单词 "lasergun"）
```

---

### Q3: 显式 metadata 这一步在做什么？看原本的 metas 数据么？这一步 AI 介入么？

**答案：**

**Level 1（显式 Metadata）的作用**：
1. **读取原始 metadata 中的 `category` 字段**（`raw_cat`）
2. **验证和规范化**：使用 `enforce_strict_category()` 确保 CatID 是合法的 UCS 标准类别
3. **别名解析**：如果 `raw_cat` 是别名（如 "Gun"），通过 `resolve_alias()` 解析为标准 CatID（如 "WPNGun"）

**是否涉及 AI**：
- ❌ **不涉及 AI**：纯查表验证和别名解析
- ✅ **只看原始 metadata**：直接读取数据库中的 `category` 字段
- ✅ **不进行向量化**：不调用 `VectorEngine`

**工作流程**：
```
原始 metadata: {"category": "AIRBlow"}
→ 检查: "AIRBlow" 是否是有效的 UCS CatID
→ 验证: 在 valid_categories 中 ✓
→ 返回: "AIRBlow"

原始 metadata: {"category": "Gun"}
→ 检查: "Gun" 是否是有效的 UCS CatID
→ 验证: 不在 valid_categories 中
→ 别名解析: "Gun" → "WPNGun"（通过 ucs_alias.csv）
→ 返回: "WPNGun"
```

---

### Q4: 还是说只有最后一步 AI 才会根据所有 meta 信息去判断？

**答案：是的，只有 Level 2（AI 向量匹配）使用 AI。**

**AI 使用的信息**：
- ✅ **使用 `rich_text`**：包含所有相关字段的拼接
- ✅ **语义理解**：AI 可以理解复杂的语义关系
- ✅ **向量相似度**：与 754 个 UCS CatID 的向量质心比较

**其他步骤不使用 AI**：
- ❌ Level -1（短路逻辑）：纯字符串匹配
- ❌ Level 0（强规则）：正则表达式整词匹配
- ❌ Level 1（显式 Metadata）：查表验证和别名解析

**AI 的执行时机**：
- 只有在**所有前面的步骤都失败**时，才会执行 AI 预测
- 如果前面的步骤已经找到有效的 CatID，**不会执行 AI**

---

## 流程图

```
输入: meta_dict
  │
  ├─→ Level -1: 短路逻辑（filename）
  │   ├─→ 找到 CatID? → ✅ 返回（结束）
  │   └─→ 未找到 → 继续
  │
  ├─→ Level 0: 强规则（rich_text）
  │   ├─→ 找到关键词? → ✅ 返回（结束）
  │   └─→ 未找到 → 继续
  │
  ├─→ Level 1: 显式 Metadata（raw_cat）
  │   ├─→ 验证成功? → ✅ 返回（结束）
  │   └─→ 验证失败 → 继续
  │
  └─→ Level 2: AI 向量匹配（rich_text）🤖
      ├─→ 相似度 > 0.4? → ✅ 返回 CatID
      └─→ 相似度 ≤ 0.4 → ❌ 返回 "UNCATEGORIZED"
```

---

## 总结

1. **短路逻辑（Level -1）**：最高优先级，只检查文件名，一旦匹配成功立即返回
2. **强规则（Level 0）**：在富文本中查找关键词，使用整词匹配（完全匹配）
3. **显式 Metadata（Level 1）**：验证原始 metadata 中的 category 字段，不涉及 AI
4. **AI 预测（Level 2）**：唯一使用 AI 的步骤，使用所有 metadata 信息进行语义匹配

**关键点**：
- ✅ 一旦在某一级找到有效分类，立即返回，不会继续执行后续逻辑
- ✅ 只有 Level 2 使用 AI，其他步骤都是纯查表或字符串匹配
- ✅ Level 0 和 Level 2 都使用 `rich_text`（包含所有相关字段）
- ✅ Level 0 使用整词匹配（完全匹配），不是部分匹配

---

## 分类与UMAP计算的关联

### 分类结果如何影响坐标计算

**关键点**: 分类结果（CatID）直接影响UCS模式的坐标计算方式

**UCS模式（定锚群岛策略）**:
1. **主类别分组**: 根据分类结果（CatID）获取主类别（Main Category）
   - 例如：`ANMLAqua` → 主类别 `ANIMALS`
   - 例如：`WEAPSwrd` → 主类别 `WEAPONS`

2. **按主类别分组数据**: 
   - 所有 `ANIMALS` 主类别的数据会被分到同一组
   - 所有 `WEAPONS` 主类别的数据会被分到另一组

3. **独立局部UMAP计算**:
   - 每个主类别独立运行局部UMAP
   - 使用该类别的固定坐标配置（`ucs_coordinates.json`）
   - 确保同一主类别的数据在同一固定区域内

4. **坐标放置**:
   - 局部坐标归一化并平移到固定中心
   - 最终坐标 = 固定中心坐标 + (局部坐标 × 有效半径)

**Gravity模式（全局UMAP）**:
- 分类结果不影响坐标计算
- 使用纯无监督全局UMAP
- 基于声学特征相似度分布

**重要性**:
- ✅ **分类准确性直接影响UCS模式布局**: 错误的分类会导致数据被放到错误的大类区域
- ✅ **分类结果用于主类别分组**: 只有正确的分类才能确保数据分到正确的大类
- ✅ **Level -1/0/1/2的优先级很重要**: 高优先级分类（如文件名中的CatID）最可靠

**示例**:
```
文件: "ANMLAqua_Whale_01.wav"
分类结果: CatID = "ANMLAqua" (Level -1, 从文件名提取)
主类别: "ANIMALS"
→ 在UCS模式中，此文件会被分到 ANIMALS 大类
→ 运行 ANIMALS 大类的局部UMAP
→ 放置到 ANIMALS 的固定坐标区域

如果分类失败:
分类结果: CatID = "UNCATEGORIZED"
→ 在UCS模式中，此文件会被放置到原点 (0, 0)
```

---

## 数据管道与工具链

### 工具链流程

```
1. 数据准备阶段
   ├─→ data_config/ucs_alias.csv（人工维护）
   │   └─→ 格式：Keyword, CatID
   │   └─→ 示例：laser gun, LASRGun
   │
   ├─→ tools/standardize_alias_csv.py（标准化工具）
   │   ├─→ 输入：ucs_alias.csv（可能有格式问题）
   │   ├─→ 作用：检测表头、验证 CatID、规范化格式
   │   ├─→ 输出：标准化的 ucs_alias.csv（带表头，CatID 验证通过）
   │   └─→ 备份：ucs_alias.csv.backup
   │
   └─→ data_config/ucs_catid_list.csv（UCS 标准定义）
       └─→ 包含 754 个标准 CatID（如 GUNMisc, GUNRif, WEAPArmr）

2. 规则生成阶段
   └─→ tools/generate_rules_json.py（规则生成器）
       ├─→ 输入：
       │   ├─→ data_config/ucs_alias.csv（标准化后的）
       │   └─→ data_config/ucs_catid_list.csv（用于验证）
       │
       ├─→ 处理流程：
       │   1. 读取 ucs_catid_list.csv，构建有效 CatID 集合（原始值 + 大写值）
       │   2. 读取 ucs_alias.csv，遍历每一行
       │   3. 对关键词进行归一化（normalize_keyword，保留空格）
       │   4. 验证 CatID 是否在有效集合中（大小写不敏感）
       │   5. 按关键词长度降序排序（最长优先）
       │   6. 去重（如果关键词重复，保留最长的）
       │
       ├─→ 输出：
       │   └─→ data_config/rules.json
       │       └─→ 格式：{"keyword": "catid", ...}
       │       └─→ 示例：{"laser gun": "LASRGun", "metal door": "METLDoor"}
       │
       └─→ 作用：为 Level 0（强规则）提供关键词到 CatID 的映射

3. 分类执行阶段
   └─→ core/data_processor.py（分类器）
       ├─→ 输入：
       │   ├─→ data_config/rules.json（由 generate_rules_json.py 生成）
       │   ├─→ metadata（从数据库读取）
       │   └─→ rich_text（由 data/importer.py 构建）
       │
       ├─→ 使用规则：
       │   └─→ Level 0（强规则）使用 rules.json 进行整词匹配
       │
       └─→ 输出：
           └─→ 分类结果（CatID + 来源）

4. 坐标计算阶段（UCS模式）
   └─→ core/layout_engine.py（布局引擎）
       ├─→ 输入：
       │   ├─→ cache/embeddings.npy（向量矩阵）
       │   ├─→ cache/metadata.pkl（元数据，包含分类结果）
       │   └─→ data_config/ucs_coordinates.json（UCS坐标配置）
       │
       ├─→ 处理流程：
       │   1. 从分类结果提取主类别（根据CatID）
       │   2. 按主类别分组数据
       │   3. 对每个大类独立运行局部UMAP
       │   4. 归一化并平移到固定坐标
       │
       └─→ 输出：
           └─→ cache/coordinates_ucs.npy（UCS模式坐标）

5. 验证阶段（可选）
   └─→ tools/verify_subset.py（微缩验证工具）
       ├─→ 输入：
       │   ├─→ 关键词（命令行参数）
       │   ├─→ SQLite 数据库（test_assets/Sonic.sqlite）
       │   ├─→ data_config/rules.json（由 generate_rules_json.py 生成）
       │   └─→ data_config/ucs_coordinates.json（UCS模式需要）
       │
       ├─→ 处理流程：
       │   1. 从数据库查询包含关键词的数据
       │   2. 运行 DataProcessor 的分类逻辑（Level -1, 0, 1, 2）
       │   3. 根据 `--mode` 参数计算坐标（UCS或Gravity模式）
       │   4. 生成 UMAP 可视化散点图
       │   5. 打印分类报告
       │
       └─→ 输出：
           ├─→ PNG 图片（默认 verify_{keyword}_{timestamp}.png）
           ├─→ CSV 文件（详细数据，包含坐标）
           └─→ 控制台报告（分类来源统计）
```

---

## 工具详细说明

### 1. `tools/standardize_alias_csv.py` - CSV 标准化工具

**作用**：标准化 `ucs_alias.csv` 文件格式，确保数据质量

**输入**：
- `data_config/ucs_alias.csv`（可能有格式问题）

**处理**：
1. 自动检测 CSV 是否有表头（`Keyword, CatID`）
2. 如果没有表头，自动添加
3. 加载 UCSManager，验证所有 CatID 是否有效
4. 规范化 CatID 格式（转大写，保留原始格式）

**输出**：
- 标准化的 `data_config/ucs_alias.csv`（带表头，格式正确）
- 备份文件：`data_config/ucs_alias.csv.backup`

**规范**：
- CSV 必须有两列：`Keyword, CatID`
- CatID 必须是有效的 UCS 标准 CatID（在 `ucs_catid_list.csv` 中）
- 关键词中的空格会被保留（用于整词匹配）

**使用时机**：
- 首次创建 `ucs_alias.csv` 时
- 手动编辑 CSV 后，需要验证格式时
- 从外部数据源导入数据后

**下一个工具**：`tools/generate_rules_json.py`

---

### 2. `tools/generate_rules_json.py` - 规则生成器

**作用**：从 `ucs_alias.csv` 生成 `rules.json`，供 Level 0（强规则）使用

**输入**：
- `data_config/ucs_alias.csv`（标准化后的，必须有表头）
- `data_config/ucs_catid_list.csv`（用于验证 CatID）

**处理流程**：
1. **读取 CatID 列表**：
   - 读取 `ucs_catid_list.csv`
   - 构建有效 CatID 集合（同时添加原始值和大写值，支持大小写不敏感匹配）
   - 例如：`GUNMisc` → 添加 `GUNMisc` 和 `GUNMISC`

2. **读取 Alias CSV**：
   - 读取 `ucs_alias.csv`
   - 检查表头（`Keyword, CatID`）
   - 如果没有表头，自动添加

3. **归一化关键词**：
   - 使用 `core.text_utils.normalize_keyword()` 归一化关键词
   - **保留空格**（关键：`"laser gun"` 与 `"lasergun"` 是不同的）
   - 例如：`"Laser Gun"` → `"laser gun"`

4. **验证 CatID**：
   - 检查 CatID 是否在有效集合中（大小写不敏感）
   - 如果无效，跳过并警告

5. **排序和去重**：
   - 按关键词长度降序排序（最长优先）
   - 如果关键词重复，保留最长的（避免短关键词误匹配长短语）
   - 例如：`"metal door"` (len 10) 优先于 `"door"` (len 4)

**输出**：
- `data_config/rules.json`
  - 格式：`{"keyword": "catid", ...}`
  - 示例：`{"laser gun": "LASRGun", "metal door": "METLDoor"}`
  - 规则按关键词长度降序排列

**规范**：
- 关键词必须归一化（小写，保留空格）
- CatID 必须是有效的 UCS 标准 CatID
- 规则按关键词长度降序排序（最长优先）

**使用时机**：
- 更新 `ucs_alias.csv` 后，必须运行此脚本重新生成 `rules.json`
- 首次设置系统时
- 添加新的关键词映射后

**下一个工具**：`core/data_processor.py`（在运行时使用 `rules.json`）

---

### 3. `core/data_processor.py` - 分类器（运行时）

**作用**：执行 4 级瀑布流分类逻辑

**输入**：
- `data_config/rules.json`（由 `generate_rules_json.py` 生成）
- `metadata`（从数据库读取）
- `rich_text`（由 `data/importer.py` 构建）

**使用规则**：
- **Level 0（强规则）**：
  - 读取 `rules.json`
  - 在 `rich_text` 中查找关键词（整词匹配：`\b{keyword}\b`）
  - 如果匹配成功，返回对应的 CatID

**输出**：
- 分类结果（CatID + 来源）
- 例如：`("LASRGun", "Level 0 (规则)")`

**规范**：
- `rules.json` 必须存在且格式正确
- 关键词匹配使用整词匹配（完全匹配）
- 匹配顺序按关键词长度降序（最长优先）

**使用时机**：
- 运行时自动使用（不需要手动调用）
- 每次分类时都会读取 `rules.json`

**下一个工具**：`tools/verify_subset.py`（可选，用于验证）

---

### 4. `tools/extract_category_centroids.py` - UCS坐标配置生成器

**作用**：从现有坐标数据提取82个大类的质心和半径，生成UCS坐标配置

**输入**：
- `cache/coordinates_ucs.npy` 或 `cache/coordinates.npy`（坐标数据）
- `cache/metadata.pkl`（元数据，用于主类别分组）
- `data_config/ucs_catid_list.csv`（UCS标准定义，用于提取所有82个大类）

**处理流程**：
1. 加载坐标数据和元数据
2. 按主类别分组
3. 对每个大类计算中位数质心（Median，避免离群点影响）
4. 使用1.5×IQR过滤离群点
5. 使用2%-98%分位数范围计算半径
6. 计算gap_buffer（自适应：15% for radius < 50, 12% for 50-200, 10% for > 200）
7. 为没有数据的类别设置默认值

**输出**：
- `data_config/ucs_coordinates.json`（UCS坐标配置）
  - 包含82个大类的固定坐标、半径、gap_buffer等

**规范**：
- 使用中位数而非均值，避免离群点影响
- 半径有最大值限制（300.0）
- gap_buffer自适应计算

**使用时机**：
- 首次运行UCS模式前
- 数据更新后需要重新计算大类范围
- 调整坐标布局后

**下一个工具**：`recalculate_umap.py` 或 `rebuild_atlas.py`（使用生成的配置计算坐标）

---

### 5. `tools/verify_subset.py` - 微缩验证工具

**作用**：快速验证分类效果和坐标计算效果，无需运行全量构建

**输入**：
- 关键词（命令行参数，如 `AIR`, `WEAPON`）
- SQLite 数据库（默认从配置文件读取）
- `data_config/rules.json`（由 `generate_rules_json.py` 生成）
- `data_config/ucs_coordinates.json`（UCS模式需要）

**处理流程**：
1. 从数据库查询包含关键词的数据（默认 500 条）
2. 运行 DataProcessor 的分类逻辑（Level -1, 0, 1, 2）
3. 根据 `--mode` 参数计算坐标：
   - `--mode ucs`: 使用 `compute_ucs_layout()`（定锚群岛策略）
   - `--mode gravity`: 使用 `compute_gravity_layout()`（全局UMAP）
4. 生成 UMAP 可视化散点图（支持LOD 0标签）
5. 打印分类报告（分类来源统计、类别分布）
6. 导出CSV文件（包含坐标信息）

**输出**：
- PNG 图片（`verify_output/verify_{keyword}_{timestamp}.png`）
- CSV 文件（`verify_output/verify_{keyword}_details_{timestamp}.csv`）
  - 包含文件名、CatID、主类别、分类来源、UMAP_X、UMAP_Y等
- 控制台报告：
  - 分类来源统计（Level -1, 0, 1, 2 各有多少）
  - 主类别分布（每个主类别有多少条）
  - CatID 分布（每个 CatID 有多少条）
  - 详细结果（前20条，包含坐标信息）

**规范**：
- 关键词可以是任意字符串（会用于 SQL LIKE 查询）
- 数据库必须存在且可读
- `rules.json` 必须存在（用于 Level 0 匹配）
- UCS模式需要 `ucs_coordinates.json`（如不存在会回退到简化UMAP）

**使用时机**：
- 更新 `ucs_alias.csv` 和 `rules.json` 后，验证分类效果
- 调整UCS坐标配置后，验证布局效果
- 调试分类逻辑或坐标计算时
- 快速测试新关键词映射时

**下一个工具**：无（这是验证工具，不生成数据）

---

## 数据文件规范

### `data_config/ucs_alias.csv`

**格式**：
```csv
Keyword,CatID
laser gun,LASRGun
metal door,METLDoor
sword hit,WEAPSwrd
```

**规范**：
- 必须有表头：`Keyword, CatID`
- 关键词中的空格会被保留（用于整词匹配）
- CatID 必须是有效的 UCS 标准 CatID（在 `ucs_catid_list.csv` 中）
- 支持多行，每行一个映射

**维护**：
- 人工维护（可以手动编辑或使用 LLM 生成）
- 使用 `tools/standardize_alias_csv.py` 验证格式

---

### `data_config/rules.json`

**格式**：
```json
{
  "laser gun": "LASRGun",
  "metal door": "METLDoor",
  "sword hit": "WEAPSwrd"
}
```

**规范**：
- 关键词已归一化（小写，保留空格）
- CatID 已验证（都是有效的 UCS 标准 CatID）
- 规则按关键词长度降序排序（最长优先）

**生成**：
- 由 `tools/generate_rules_json.py` 自动生成
- **不要手动编辑**（会被覆盖）

---

### `data_config/ucs_catid_list.csv`

**格式**：
```csv
Category,SubCategory,CatID,CatShort,...
GUNS,MISC,GUNMisc,GUN,...
WEAPONS,SWORD,WEAPSwrd,WEAP,...
```

**规范**：
- 包含 754 个标准 UCS CatID
- CatID 格式：大小写混合（如 `GUNMisc`, `WEAPSwrd`）
- 这是 UCS 标准的权威定义

**维护**：
- 由 UCS 标准定义（通常不需要修改）

---

## 完整工作流程示例

### 场景：添加新的关键词映射

1. **编辑 CSV**：
   ```bash
   # 手动编辑 data_config/ucs_alias.csv
   # 添加新行：magic fireball, MAGCFIRE
   ```

2. **标准化 CSV**（可选，但推荐）：
   ```bash
   python tools/standardize_alias_csv.py
   # 验证格式，规范化 CatID
   ```

3. **生成规则**：
   ```bash
   python tools/generate_rules_json.py
   # 从 CSV 生成 rules.json
   ```

4. **验证效果**（可选）：
   ```bash
   python tools/verify_subset.py magic
   # 验证 "magic" 关键词的分类效果
   ```

5. **使用**：
   - 运行 `rebuild_atlas.py` 或启动 UI
   - 系统会自动使用新的 `rules.json` 进行分类

---

## 关键注意事项

1. **数据流向**：
   - `ucs_alias.csv` → `generate_rules_json.py` → `rules.json` → `data_processor.py`
   - 更新 CSV 后，**必须**运行 `generate_rules_json.py` 重新生成 `rules.json`

2. **CatID 格式统一**：
   - **官方 UCS 格式**：大小写混合（如 `GUNMisc`, `WEAPSwrd`）
   - **存储格式**：统一使用原始格式（官方 UCS 格式）
     - `rules.json` 中的 CatID 使用原始格式
     - `ucs_manager.catid_to_category` 的 key 使用原始格式
     - 数据库中的 `category` 字段使用原始格式
   - **查找方式**：大小写不敏感（支持 `GUNMisc`, `GUNMISC`, `gunmisc` 都能找到）
   - **返回格式**：统一返回原始格式（通过 `enforce_strict_category()`）
   - **详细说明**：参考 `Docs/CatID_Format_Standardization.md`

3. **关键词归一化**：
   - 关键词必须归一化（小写，保留空格）
   - 例如：`"Laser Gun"` → `"laser gun"`
   - 空格很重要：`"laser gun"` 与 `"lasergun"` 是不同的关键词

4. **排序策略**：
   - 规则按关键词长度降序排序（最长优先）
   - 确保 `"metal door"` 优先于 `"door"` 匹配
   - 避免短关键词误匹配长短语

5. **分类与坐标计算的关联**：
   - 分类结果（CatID）用于确定主类别（Main Category）
   - 主类别用于UCS模式的坐标分组和计算
   - 错误的分类会导致数据被放到错误的大类区域
   - 高优先级分类（Level -1文件名短路）最可靠

